#pragma once
extern byte KVCPU[0x10];

const BYTE retailKey[0x10] = { 0xE1, 0xBC, 0x15, 0x9C, 0x73, 0xB1, 0xEA, 0xE9, 0xAB, 0x31, 0x70, 0xF3, 0xAD, 0x47, 0xEB, 0xF3 };
const BYTE DeveloperKey[0x10] = { 0xDA, 0xB6, 0x9A, 0xD9, 0x8E, 0x28, 0x76, 0x4F, 0x97, 0x7E, 0xE2, 0x48, 0x7E, 0x4F, 0x3F, 0x68 };

const BYTE masterKey[272] = {
    0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xDD, 0x5F, 0x49, 0x6F, 0x99, 0x4D, 0x37, 0xBB, 0xE4, 0x5B, 0x98, 0xF2, 0x5D, 0xA6, 0xB8, 0x43, 
    0xBE, 0xD3, 0x10, 0xFD, 0x3C, 0xA4, 0xD4, 0xAC, 0xE6, 0x92, 0x3A, 0x79, 0xDB, 0x3B, 0x63, 0xAF, 
    0x38, 0xCD, 0xA0, 0xE5, 0x85, 0x72, 0x01, 0xF9, 0x0E, 0x5F, 0x5A, 0x5B, 0x08, 0x4B, 0xAD, 0xE2, 
    0xA0, 0x2A, 0x42, 0x33, 0x85, 0x34, 0x53, 0x83, 0x1E, 0xE5, 0x5B, 0x8F, 0xBF, 0x35, 0x8E, 0x63, 
    0xD8, 0x28, 0x8C, 0xFF, 0x03, 0xDC, 0xC4, 0x35, 0x02, 0xE4, 0x0D, 0x1A, 0xC1, 0x36, 0x9F, 0xBB, 
    0x90, 0xED, 0xDE, 0x4E, 0xEC, 0x86, 0x10, 0x3F, 0xE4, 0x1F, 0xFD, 0x96, 0xD9, 0x3A, 0x78, 0x25, 
    0x38, 0xE1, 0xD3, 0x8B, 0x1F, 0x96, 0xBD, 0x84, 0xF6, 0x5E, 0x2A, 0x56, 0xBA, 0xD0, 0xA8, 0x24, 
    0xE5, 0x02, 0x8F, 0x3C, 0xA1, 0x9A, 0xEB, 0x93, 0x59, 0xD7, 0x1B, 0x99, 0xDA, 0xC4, 0xDF, 0x7B, 
    0xD0, 0xC1, 0x9A, 0x12, 0xCC, 0x3A, 0x17, 0xBF, 0x6E, 0x4D, 0x78, 0x87, 0xD4, 0x2A, 0x7F, 0x6B, 
    0x9E, 0x2F, 0xCD, 0x8D, 0x4E, 0xF5, 0xCE, 0xC2, 0xA0, 0x5A, 0xA3, 0x0F, 0x9F, 0xAD, 0xFE, 0x12, 
    0x65, 0x74, 0x20, 0x6F, 0xF2, 0x5C, 0x52, 0xE4, 0xB0, 0xC1, 0x3C, 0x25, 0x0D, 0xAE, 0xD1, 0x82, 
    0x7C, 0x60, 0xD7, 0x44, 0xE5, 0xCD, 0x8B, 0xEA, 0x6C, 0x80, 0xB5, 0x1B, 0x7A, 0x0C, 0x02, 0xCE, 
    0x0C, 0x24, 0x51, 0x3D, 0x39, 0x36, 0x4A, 0x3F, 0xD3, 0x12, 0xCF, 0x83, 0x8D, 0x81, 0x56, 0x00, 
    0xB4, 0x64, 0x79, 0x86, 0xEA, 0xEC, 0xB6, 0xDE, 0x8A, 0x35, 0x7B, 0xAB, 0x35, 0x4E, 0xBB, 0x87, 
    0xEA, 0x1D, 0x47, 0x8C, 0xE1, 0xF3, 0x90, 0x13, 0x27, 0x97, 0x55, 0x82, 0x07, 0xF2, 0xF3, 0xAA, 
    0xF9, 0x53, 0x47, 0x8F, 0x74, 0xA3, 0x8E, 0x7B, 0xAE, 0xB8, 0xFC, 0x77, 0xCB, 0xFB, 0xAB, 0x8A
};

const DWORD CBTypes[6] = { 0x10B0524, 0x10C0AD0, 0x10C0AD8, 0x10C0FFB, 0x304000D, 0x304000E };
extern QWORD kvAddr;

typedef enum{
	XENON = 0x34323761,
	ZEPHYR = 0x39383130,
	FALCON = 0x39393430,
	JASPER = 0x39393564,
	TRINITY = 0x39386662,
	CORONA = 0x39386661
}CONSOLE_TYPES;

typedef enum _ODD_POLICY {
    ODD_POLICY_FLAG_CHECK_FIRMWARE = 0x120, 
} ODD_POLICY;

#ifndef DEBUG_FIXPDBLOAD
#pragma pack(push, 1)
#endif

typedef union _INQUIRY_DATA {
    struct {
        BYTE DeviceType          : 5;
        BYTE DeviceTypeQualifier : 3;
        BYTE DeviceTypeModifier  : 7;
        BYTE RemovableMedia      : 1;
        BYTE Versions            : 8;
        BYTE ResponseDataFormat  : 4;
        BYTE HiSupport           : 1;
        BYTE NormACA             : 1;
        BYTE ReservedBit         : 1;
        BYTE AERC                : 1;
        BYTE AdditionalLength    : 8;
        WORD Reserved            : 16;
        BYTE SoftReset           : 1;
        BYTE CommandQueue        : 1;
        BYTE Reserved2           : 1;
        BYTE LinkedCommands      : 1;
        BYTE Synchronous         : 1;
        BYTE Wide16Bit           : 1;
        BYTE Wide32Bit           : 1;
        BYTE RelativeAddressing  : 1;
        BYTE VendorId[8];
        BYTE ProductId[16];
        BYTE ProductRevisionLevel[4];
    };
    BYTE Data[0x24];
} INQUIRY_DATA, *pINQUIRY_DATA;

#ifdef DEBUG_FIXPDBLOAD
#pragma pack(push, 1)
#endif

typedef struct _XEIKA_ODD_DATA {
    BYTE         Version;
    BYTE         PhaseLevel;
    INQUIRY_DATA InquiryData;
} XEIKA_ODD_DATA, *PXEIKA_ODD_DATA;

typedef struct _XEIKA_DATA {
    XECRYPT_RSAPUB_2048 PublicKey;
    DWORD               Signature;
    WORD                Version;
    XEIKA_ODD_DATA      OddData;
    BYTE                Padding[4];
} XEIKA_DATA, *PXEIKA_DATA;

typedef struct _XEIKA_CERTIFICATE {
    WORD       Size;
    XEIKA_DATA Data;
    BYTE       Padding[0x1146];
} XEIKA_CERTIFICATE, *PXEIKA_CERTIFICATE;


typedef struct _KEY_VAULT {                     // Key #
    BYTE  HmacShaDigest[0x10];
    BYTE  Confounder[0x08];
    BYTE  ManufacturingMode;                    // 0x00
    BYTE  AlternateKeyVault;                    // 0x01
    BYTE  RestrictedPrivilegesFlags;            // 0x02
    BYTE  ReservedByte3;                        // 0x03
    WORD  OddFeatures;                          // 0x04
    WORD  OddAuthtype;                          // 0x05
    DWORD RestrictedHvextLoader;                // 0x06
    DWORD PolicyFlashSize;                      // 0x07
    DWORD PolicyBuiltinUsbmuSize;               // 0x08
    DWORD ReservedDword4;                       // 0x09
    QWORD RestrictedPrivileges;                 // 0x0A
    QWORD ReservedQword2;                       // 0x0B
    QWORD ReservedQword3;                       // 0x0C
    QWORD ReservedQword4;                       // 0x0D
    BYTE  ReservedKey1[0x10];                   // 0x0E
    BYTE  ReservedKey2[0x10];                   // 0x0F
    BYTE  ReservedKey3[0x10];                   // 0x10
    BYTE  ReservedKey4[0x10];                   // 0x11
    BYTE  ReservedRandomKey1[0x10];             // 0x12
    BYTE  ReservedRandomKey2[0x10];             // 0x13
    BYTE  ConsoleSerialNumber[0xC];             // 0x14
    BYTE  MoboSerialNumber[0xC];                // 0x15
    WORD  GameRegion;                           // 0x16
    BYTE  Padding1[0x6];
    BYTE  ConsoleObfuscationKey[0x10];          // 0x17
    BYTE  KeyObfuscationKey[0x10];              // 0x18
    BYTE  RoamableObfuscationKey[0x10];         // 0x19
    BYTE  DvdKey[0x10];                         // 0x1A
    BYTE  PrimaryActivationKey[0x18];           // 0x1B
    BYTE  SecondaryActivationKey[0x10];         // 0x1C
    BYTE  GlobalDevice2desKey1[0x10];           // 0x1D
    BYTE  GlobalDevice2desKey2[0x10];           // 0x1E
    BYTE  WirelessControllerMs2desKey1[0x10];   // 0x1F
    BYTE  WirelessControllerMs2desKey2[0x10];   // 0x20
    BYTE  WiredWebcamMs2desKey1[0x10];          // 0x21
    BYTE  WiredWebcamMs2desKey2[0x10];          // 0x22
    BYTE  WiredControllerMs2desKey1[0x10];      // 0x23
    BYTE  WiredControllerMs2desKey2[0x10];      // 0x24
    BYTE  MemoryUnitMs2desKey1[0x10];           // 0x25
    BYTE  MemoryUnitMs2desKey2[0x10];           // 0x26
    BYTE  OtherXsm3DeviceMs2desKey1[0x10];      // 0x27
    BYTE  OtherXsm3DeviceMs2desKey2[0x10];      // 0x28
    BYTE  WirelessController3p2desKey1[0x10];   // 0x29
    BYTE  WirelessController3p2desKey2[0x10];   // 0x2A
    BYTE  WiredWebcam3p2desKey1[0x10];          // 0x2B
    BYTE  WiredWebcam3p2desKey2[0x10];          // 0x2C
    BYTE  WiredController3p2desKey1[0x10];      // 0x2D
    BYTE  WiredController3p2desKey2[0x10];      // 0x2E
    BYTE  MemoryUnit3p2desKey1[0x10];           // 0x2F
    BYTE  MemoryUnit3p2desKey2[0x10];           // 0x30
    BYTE  OtherXsm3Device3p2desKey1[0x10];      // 0x31
    BYTE  OtherXsm3Device3p2desKey2[0x10];      // 0x32
    XECRYPT_RSAPRV_1024 ConsolePrivateKey;      // 0x33
    XECRYPT_RSAPRV_2048 XeikaPrivateKey;        // 0x34
    XECRYPT_RSAPRV_1024 CardeaPrivateKey;       // 0x35
    XE_CONSOLE_CERTIFICATE ConsoleCertificate;  // 0x36
    XEIKA_CERTIFICATE XeikaCertificate;         // 0x37
    BYTE  KeyVaultSignature[0x100];             // 0x44
    BYTE  CardeaCertificate[0x2108];            // 0x38
} KEY_VAULT, *PKEY_VAULT;
#pragma pack(pop)

namespace KV{
	extern DWORD updateSequence;
	extern bool type1KV;
	extern bool FCRT;
	extern bool CRL;
	extern byte CPUKeyDigest[0x14];
	extern byte KVDigest[0x14];

	BOOL verifyKeyVault();
	HRESULT setKeyVaultBytes(BYTE* KeyVault);
	void processCPUKey(CHAR* FilePath);
	HRESULT processKeyVault();
	CONSOLE_TYPE getConsoleType();
	HRESULT setKeyVault(CHAR* FilePath);
	HRESULT loadKeyVault(CHAR* FilePath);
	bool setKV();
	DWORD hardwareFlags();
}